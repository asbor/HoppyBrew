name: Release Automation

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release (e.g. v1.0.0)"
        required: false
      release-notes:
        description: "Optional custom release notes"
        required: false
  release:
    types:
      - created
  push:
    tags:
      - "v*"

permissions:
  contents: write
  issues: write
  deployments: write
  discussions: write

env:
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "20"

jobs:
  validate-artifacts:
    name: Validate Artifacts
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install backend dependencies
        working-directory: services/backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run backend smoke tests
        working-directory: services/backend
        env:
          PYTHONPATH: ${{ github.workspace }}/services/backend
        run: pytest -q

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: yarn
          cache-dependency-path: services/nuxt3-shadcn/yarn.lock

      - name: Install frontend dependencies
        working-directory: services/nuxt3-shadcn
        run: yarn install --frozen-lockfile

      - name: Run frontend smoke tests
        working-directory: services/nuxt3-shadcn
        run: |
          yarn run generate
          yarn run build

  build-release-artifacts:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    needs: validate-artifacts
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Archive backend package
        run: |
          tar czf backend-${{ github.sha }}.tar.gz -C services/backend .
          echo "BACKEND_ARCHIVE=backend-${{ github.sha }}.tar.gz" >> $GITHUB_ENV

      - name: Archive frontend package
        run: |
          tar czf frontend-${{ github.sha }}.tar.gz -C services/nuxt3-shadcn .
          echo "FRONTEND_ARCHIVE=frontend-${{ github.sha }}.tar.gz" >> $GITHUB_ENV

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-packages
          path: |
            backend-${{ github.sha }}.tar.gz
            frontend-${{ github.sha }}.tar.gz

  publish-docker-images:
    name: Publish Docker Images
    runs-on: ubuntu-latest
    needs: validate-artifacts
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        service:
          - name: backend
            context: services/backend
            dockerfile: services/backend/Dockerfile
          - name: frontend
            context: services/nuxt3-shadcn
            dockerfile: services/nuxt3-shadcn/Dockerfile
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to DockerHub
        if: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract version from tag
        id: version
        run: |
          TAG_NAME="${{ github.ref_name }}"
          if [[ "$TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            VERSION="${TAG_NAME#v}"
            MAJOR="${VERSION%%.*}"
            MINOR="${VERSION%.*}"
            echo "version=$VERSION" >> "$GITHUB_OUTPUT"
            echo "major=$MAJOR" >> "$GITHUB_OUTPUT"
            echo "minor=$MINOR" >> "$GITHUB_OUTPUT"
            echo "is_semver=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_semver=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Build and push to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ghcr.io/${{ github.repository }}-${{ matrix.service.name }}:${{ github.ref_name }}
            ghcr.io/${{ github.repository }}-${{ matrix.service.name }}:latest
            ${{ steps.version.outputs.is_semver == 'true' && format('ghcr.io/{0}-{1}:{2}', github.repository, matrix.service.name, steps.version.outputs.version) || '' }}
            ${{ steps.version.outputs.is_semver == 'true' && format('ghcr.io/{0}-{1}:{2}', github.repository, matrix.service.name, steps.version.outputs.major) || '' }}
            ${{ steps.version.outputs.is_semver == 'true' && format('ghcr.io/{0}-{1}:{2}', github.repository, matrix.service.name, steps.version.outputs.minor) || '' }}
          platforms: linux/amd64
          cache-from: type=gha,scope=${{ matrix.service.name }}-release
          cache-to: type=gha,mode=max,scope=${{ matrix.service.name }}-release

      - name: Build and push to DockerHub
        if: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/hoppybrew-${{ matrix.service.name }}:${{ github.ref_name }}
            ${{ secrets.DOCKERHUB_USERNAME }}/hoppybrew-${{ matrix.service.name }}:latest
            ${{ steps.version.outputs.is_semver == 'true' && format('{0}/hoppybrew-{1}:{2}', secrets.DOCKERHUB_USERNAME, matrix.service.name, steps.version.outputs.version) || '' }}
            ${{ steps.version.outputs.is_semver == 'true' && format('{0}/hoppybrew-{1}:{2}', secrets.DOCKERHUB_USERNAME, matrix.service.name, steps.version.outputs.major) || '' }}
            ${{ steps.version.outputs.is_semver == 'true' && format('{0}/hoppybrew-{1}:{2}', secrets.DOCKERHUB_USERNAME, matrix.service.name, steps.version.outputs.minor) || '' }}
          platforms: linux/amd64
          cache-from: type=gha,scope=${{ matrix.service.name }}-release

  generate-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    needs:
      - build-release-artifacts
      - publish-docker-images
    outputs:
      body: ${{ steps.augmented.outputs.body }}
      tag-name: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Determine release tag
        id: tag
        uses: actions/github-script@v7
        with:
          script: |
            const inputTag = core.getInput('tag');
            if (inputTag) {
              core.setOutput('tag', inputTag);
              return;
            }

            if (context.eventName === 'release') {
              core.setOutput('tag', context.payload.release.tag_name);
              return;
            }

            if (context.eventName === 'push' && context.ref.startsWith('refs/tags/')) {
              core.setOutput('tag', context.ref.replace('refs/tags/', ''));
              return;
            }

            core.setFailed('Unable to resolve release tag.');
          tag: ${{ github.event.inputs.tag }}

      - name: Generate release notes
        id: release-notes
        uses: actions/github-script@v7
        with:
          script: |
            const tag = core.getInput('tag-name');
            const customNotes = core.getInput('custom-notes');
            if (customNotes) {
              core.setOutput('body', customNotes);
              return;
            }

            const { data } = await github.rest.repos.generateReleaseNotes({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
            });
            core.setOutput('body', data.body);
          tag-name: ${{ steps.tag.outputs.tag }}
          custom-notes: ${{ github.event.inputs.release-notes }}

      - name: Append MCP analytics prompt
        id: augmented
        uses: actions/github-script@v7
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        with:
          script: |
            const dockerhubUsername = process.env.DOCKERHUB_USERNAME;
            const dockerImages = [
              '### Docker Images',
              '- `ghcr.io/${{ github.repository }}-backend:${{ github.ref_name }}`',
              '- `ghcr.io/${{ github.repository }}-frontend:${{ github.ref_name }}`',
            ];
            
            if (dockerhubUsername) {
              dockerImages.push(`- \`${dockerhubUsername}/hoppybrew-backend:${{ github.ref_name }}\``);
              dockerImages.push(`- \`${dockerhubUsername}/hoppybrew-frontend:${{ github.ref_name }}\``);
            }
            
            const analytics = [
              '### Automated Checks',
              '- Backend smoke tests: ✅',
              '- Frontend smoke tests: ✅',
              '',
              '### Deployment Readiness',
              '- Docker images published to GitHub Container Registry',
              dockerhubUsername ? '- Docker images published to DockerHub' : '',
              '- Staging deployment status tracked in MCP',
              '',
              ...dockerImages,
            ].filter(line => line !== '').join('\n');

            const body = `${core.getInput('body')}\n\n${analytics}`;
            core.setOutput('body', body);
          body: ${{ steps.release-notes.outputs.body }}

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs:
      - build-release-artifacts
      - generate-notes
    steps:
      - name: Download artefacts
        uses: actions/download-artifact@v6
        with:
          name: release-packages

      - name: Publish release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.generate-notes.outputs.tag-name }}
          release_name: ${{ needs.generate-notes.outputs.tag-name }}
          draft: false
          prerelease: false
          body: ${{ needs.generate-notes.outputs.body }}
          files: |
            backend-${{ github.sha }}.tar.gz
            frontend-${{ github.sha }}.tar.gz

  mcp-release:
    name: MCP Release Intelligence
    runs-on: ubuntu-latest
    if: always()
    needs:
      - validate-artifacts
      - build-release-artifacts
      - publish-docker-images
      - generate-notes
      - create-release
    steps:
      - name: Collate release summary
        id: summary
        uses: actions/github-script@v7
        with:
          script: |
            const status = {
              validation: '${{ needs.validate-artifacts.result }}',
              packaging: '${{ needs.build-release-artifacts.result }}',
              docker: '${{ needs.publish-docker-images.result }}',
              notes: '${{ needs.generate-notes.result }}',
              publish: '${{ needs.create-release.result }}',
            };
            const body = [
              '### Release Pipeline Summary',
              '',
              `- Validation: **${status.validation}**`,
              `- Packaging: **${status.packaging}**`,
              `- Docker images: **${status.docker}**`,
              `- Notes: **${status.notes}**`,
              `- Release publish: **${status.publish}**`,
            ].join('\n');
            const failed = Object.values(status).some((value) => value !== 'success');
            core.setOutput('markdown', body);
            core.setOutput('failed', failed ? 'true' : 'false');

      - name: "MCP: Publish release analytics"
        uses: actions/github-script@v7
        env:
          MCP_SERVER_URL: ${{ secrets.MCP_SERVER_URL }}
          MCP_API_KEY: ${{ secrets.MCP_API_KEY }}
        with:
          script: |
            const url = process.env.MCP_SERVER_URL;
            if (!url) {
              core.info('MCP server URL not configured; skipping analytics dispatch.');
              return;
            }
            const payload = {
              repository: context.repo,
              workflow: 'release',
              tag: core.getInput('tag'),
              summary: core.getInput('summary'),
              releaseBody: core.getInput('release-body'),
              conclusion: '${{ job.status }}',
            };
            const response = await fetch(`${url.replace(/\/$/, '')}/github/release-report`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                ...(process.env.MCP_API_KEY ? { Authorization: `Bearer ${process.env.MCP_API_KEY}` } : {}),
              },
              body: JSON.stringify(payload),
            });
            if (!response.ok) {
              core.setFailed(`Failed to publish MCP analytics: ${response.status} ${response.statusText}`);
            } else {
              core.info('MCP analytics dispatched successfully.');
            }
          summary: ${{ steps.summary.outputs.markdown }}
          tag: ${{ needs.generate-notes.outputs.tag-name }}
          release-body: ${{ needs.generate-notes.outputs.body }}

      - name: "MCP: Auto-issue for release failures"
        if: steps.summary.outputs.failed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Release pipeline failure for ${core.getInput('tag')}`;
            const { owner, repo } = context.repo;
            const body = [
              'Automated MCP alert for release pipeline failure.',
              '',
              core.getInput('markdown'),
              '',
              '_Generated automatically by the release workflow._',
            ].join('\n');
            const { data: existing } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} "${title}" in:title state:open label:release-failure`,
            });
            if (existing.total_count > 0) {
              core.info('Existing release failure issue detected; skipping creation.');
              return;
            }
            await github.rest.issues.create({
              owner,
              repo,
              title,
              body,
              labels: ['release-failure', 'automated'],
            });
          tag: ${{ needs.generate-notes.outputs.tag-name }}
          markdown: ${{ steps.summary.outputs.markdown }}

      - name: Fail workflow if release failed
        if: steps.summary.outputs.failed == 'true'
        run: |
          echo "One or more release pipeline stages failed. Check the summary above for details."
          exit 1
