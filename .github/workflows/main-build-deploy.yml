name: Main Build & Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * *"

concurrency:
  group: main-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  packages: write
  deployments: write
  issues: write
  pull-requests: read

env:
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "20"
  REGISTRY: ghcr.io

jobs:
  backend-quality:
    name: Backend Quality Gate
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: services/backend
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        id: setup-python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('services/backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ steps.setup-python.outputs.python-version }}-

      - name: Install dependencies
        run: python -m pip install --upgrade pip && pip install -r requirements.txt

      - name: Run unit tests
        env:
          PYTHONPATH: ${{ github.workspace }}/services/backend
        run: pytest --maxfail=1 --disable-warnings --durations=25

      - name: Upload coverage report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage
          path: services/backend/htmlcov
          if-no-files-found: ignore

  frontend-quality:
    name: Frontend Quality Gate
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: services/nuxt3-shadcn
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: yarn
          cache-dependency-path: services/nuxt3-shadcn/yarn.lock

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Generate static assets
        run: yarn run generate

      - name: Build application
        run: yarn run build

      - name: Upload test artefacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-test-artifacts
          path: |
            services/nuxt3-shadcn/.nuxt
            services/nuxt3-shadcn/.output
          if-no-files-found: ignore

  docker-build:
    name: Build and Publish Images
    runs-on: ubuntu-latest
    needs:
      - backend-quality
      - frontend-quality
    strategy:
      matrix:
        service:
          - name: backend
            context: services/backend
            dockerfile: services/backend/Dockerfile
            image: backend
          - name: frontend
            context: services/nuxt3-shadcn
            dockerfile: services/nuxt3-shadcn/Dockerfile
            image: frontend
    env:
      IMAGE_TAG: ${{ github.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build image (verification)
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: false
          tags: ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service.image }}:${{ env.IMAGE_TAG }}

      - name: Log in to GHCR
        if: ${{ secrets.GHCR_USERNAME != '' && secrets.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_USERNAME }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Log in to DockerHub
        if: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Push image to GHCR
        if: ${{ secrets.GHCR_USERNAME != '' && secrets.GHCR_TOKEN != '' }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service.image }}:${{ env.IMAGE_TAG }}
            ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service.image }}:latest
          provenance: false

      - name: Push image to DockerHub
        if: ${{ secrets.DOCKERHUB_USERNAME != '' && secrets.DOCKERHUB_TOKEN != '' }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/hoppybrew-${{ matrix.service.image }}:${{ env.IMAGE_TAG }}
            ${{ secrets.DOCKERHUB_USERNAME }}/hoppybrew-${{ matrix.service.image }}:latest
          provenance: false

      - name: Emit image metadata
        id: meta
        run: |
          echo "image=${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service.image }}:${{ env.IMAGE_TAG }}" >> "$GITHUB_OUTPUT"
          echo "ghcr_pushed=$([[ -n \"${{ secrets.GHCR_TOKEN }}\" && -n \"${{ secrets.GHCR_USERNAME }}\" ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          echo "dockerhub_pushed=$([[ -n \"${{ secrets.DOCKERHUB_TOKEN }}\" && -n \"${{ secrets.DOCKERHUB_USERNAME }}\" ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          if [[ -n "${{ secrets.DOCKERHUB_USERNAME }}" ]]; then
            echo "dockerhub_image=${{ secrets.DOCKERHUB_USERNAME }}/hoppybrew-${{ matrix.service.image }}:${{ env.IMAGE_TAG }}" >> "$GITHUB_OUTPUT"
          fi

  deploy-staging:
    name: Staging Deployment
    runs-on: ubuntu-latest
    needs: docker-build
    environment:
      name: staging
    outputs:
      message: ${{ steps.status.outputs.message }}
      deployment_status: ${{ steps.status.outputs.status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect Kubernetes manifests
        id: manifest
        run: |
          if [ -d "k8s" ]; then
            echo "has_manifests=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_manifests=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare deployment manifest
        if: ${{ steps.manifest.outputs.has_manifests == 'true' }}
        run: |
          mkdir -p deploy
          cat <<'YAML' > deploy/kustomization.yaml
          resources:
            - ../k8s/backend.yaml
            - ../k8s/frontend.yaml
          YAML
        shell: bash

      - name: Configure kubeconfig
        if: ${{ secrets.STAGING_KUBE_CONFIG != '' && steps.manifest.outputs.has_manifests == 'true' }}
        run: |
          mkdir -p "$HOME/.kube"
          echo "${{ secrets.STAGING_KUBE_CONFIG }}" | base64 --decode > "$HOME/.kube/config"
          chmod 600 "$HOME/.kube/config"

      - name: Apply manifests
        if: ${{ secrets.STAGING_KUBE_CONFIG != '' && steps.manifest.outputs.has_manifests == 'true' }}
        run: kubectl apply -k deploy

      - name: Wait for rollout
        if: ${{ secrets.STAGING_KUBE_CONFIG != '' && steps.manifest.outputs.has_manifests == 'true' }}
        run: |
          kubectl rollout status deployment/backend --timeout=120s
          kubectl rollout status deployment/frontend --timeout=120s

      - name: Record deployment status
        id: status
        run: |
          if [ -z "${{ secrets.STAGING_KUBE_CONFIG }}" ]; then
            echo "status=skipped" >> "$GITHUB_OUTPUT"
            echo "message=Staging deployment skipped; credentials not configured." >> "$GITHUB_OUTPUT"
          elif [ "${{ steps.manifest.outputs.has_manifests }}" != "true" ]; then
            echo "status=skipped" >> "$GITHUB_OUTPUT"
            echo "message=Staging deployment skipped; no Kubernetes manifests detected." >> "$GITHUB_OUTPUT"
          else
            echo "status=deployed" >> "$GITHUB_OUTPUT"
            echo "message=Staging deployment completed." >> "$GITHUB_OUTPUT"
          fi

  mcp-main-report:
    name: MCP Release Automation
    runs-on: ubuntu-latest
    if: always()
    needs:
      - backend-quality
      - frontend-quality
      - docker-build
      - deploy-staging
    steps:
      - name: Compile workflow summary
        id: summary
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              backend: '${{ needs.backend-quality.result }}',
              frontend: '${{ needs.frontend-quality.result }}',
              images: '${{ needs.docker-build.result }}',
              staging: '${{ needs.deploy-staging.outputs.deployment_status || 'skipped' }}',
            };

            const allowed = new Set(['success', 'deployed', 'skipped']);
            const hasFailures = Object.values(results).some((status) => !allowed.has(status));

            const lines = [
              '### Main Branch Pipeline Summary',
              '',
              `- Backend quality gate: **${results.backend}**`,
              `- Frontend quality gate: **${results.frontend}**`,
              `- Container build: **${results.images}**`,
              `- Staging deployment: **${results.staging}**`,
            ];

            core.setOutput('markdown', lines.join('\n'));
            core.setOutput('failed', hasFailures ? 'true' : 'false');

      - name: "MCP: Publish deployment analytics"
        uses: actions/github-script@v7
        env:
          MCP_SERVER_URL: ${{ secrets.MCP_SERVER_URL }}
          MCP_API_KEY: ${{ secrets.MCP_API_KEY }}
          STAGING_MESSAGE: ${{ needs.deploy-staging.outputs.message }}
        with:
          script: |
            const url = process.env.MCP_SERVER_URL;
            if (!url) {
              core.info('MCP server URL not configured; skipping analytics dispatch.');
              return;
            }

            const payload = {
              repository: context.repo,
              workflow: 'main-build-deploy',
              commit: context.sha,
              summary: core.getInput('summary'),
              stages: {
                backendQuality: '${{ needs.backend-quality.result }}',
                frontendQuality: '${{ needs.frontend-quality.result }}',
                dockerBuild: '${{ needs.docker-build.result }}',
                deployStaging: '${{ needs.deploy-staging.outputs.deployment_status || needs.deploy-staging.result }}',
              },
              stagingNote: process.env.STAGING_MESSAGE || '',
              conclusion: '${{ job.status }}',
            };

            const response = await fetch(`${url.replace(/\/$/, '')}/github/deployment-report`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                ...(process.env.MCP_API_KEY ? { Authorization: `Bearer ${process.env.MCP_API_KEY}` } : {}),
              },
              body: JSON.stringify(payload),
            });

            if (!response.ok) {
              core.setFailed(`Failed to publish MCP analytics: ${response.status} ${response.statusText}`);
            } else {
              core.info('MCP analytics dispatched successfully.');
            }
          summary: ${{ steps.summary.outputs.markdown }}

      - name: "MCP: Auto-issue for pipeline failures"
        if: steps.summary.outputs.failed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Main pipeline failure for ${context.sha.substring(0, 7)}`;
            const { owner, repo } = context.repo;
            const body = [
              'Automated MCP alert for main branch pipeline failure.',
              '',
              core.getInput('markdown'),
              '',
              '_Generated automatically by the CI/CD pipeline._',
            ].join('\n');

            const { data: existing } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} "${title}" in:title state:open label:ci-failure`,
            });

            if (existing.total_count > 0) {
              core.info('Existing main pipeline failure issue detected; skipping creation.');
              return;
            }

            await github.rest.issues.create({
              owner,
              repo,
              title,
              body,
              labels: ['ci-failure', 'automated'],
            });
          markdown: ${{ steps.summary.outputs.markdown }}

      - name: Fail workflow if any stage failed
        if: steps.summary.outputs.failed == 'true'
        run: |
          echo "One or more pipeline stages failed. Check the summary above for details."
          exit 1
